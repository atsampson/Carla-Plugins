// generated by Fast Light User Interface Designer (fluid) version 1.0300

#include "external/zynaddsubfx/UI/OscilGenUI.h"
//Copyright (c) 2002-2005 Nasca Octavian Paul
//License: GNU GPL version 2 or later
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

OGSlider::OGSlider(int x,int y, int w, int h, const char *label)
  :Fl_Osc_TSlider(x,y,w,h,label) {
  phase=false;
}

void OGSlider::OSC_value(char c) {
  value(phase ? c : 127-c);
    selection_color(value() == reset_value ? 0 : 222);
    redraw();
}

void OGSlider::cb(void) {
  selection_color(value() == reset_value ? 0 : 222);
    if(cb_data.first) cb_data.first(this, cb_data.second);
}

void OGSlider::update(void) {
}

OGWaveChoice::OGWaveChoice(int x,int y, int w, int h, const char *label)
   :Fl_Osc_Choice(x,y,w,h,label) {
}

void OGWaveChoice::OSC_value(int i) {
  value(i == 127 ? size()-2 : i);
     ogui->setbfmodstatus(i);
}

void OGWaveChoice::cb(void) {
  int v = Fl_Osc_Choice::value();
  	if (value() < size()-2)
  	    oscWrite(ext, "i", v);
  	else
  	    oscWrite(ext);
  	if(cb_data.first)
  	    cb_data.first(this, cb_data.second);
}

void Oscilharmonic::cb_mag_i(OGSlider* o, void*) {
  int x=127-(int)o->value();
//if (x==64) o->selection_color(0);
//    else o->selection_color(222);

 o->osc->writeValue(o->loc+"magnitude"+to_s(n), (char)x);
 if (x==64) {
    o->osc->writeValue(o->loc+"phase"+to_s(n), (char)64);
    phase->value(64);
    phase->selection_color(0);
 }
 o->osc->requestValue(o->loc+"prepare");
 o->osc->requestValue(o->loc+"spectrum");
 o->osc->requestValue(o->loc+"waveform");

display->redraw();
}
void Oscilharmonic::cb_mag(OGSlider* o, void* v) {
  ((Oscilharmonic*)(o->parent()->user_data()))->cb_mag_i(o,v);
}

void Oscilharmonic::cb_phase_i(OGSlider* o, void*) {
  o->osc->writeValue(o->loc+"phase"+to_s(n), (char) o->value());
o->osc->requestValue(o->loc+"prepare");
o->osc->requestValue(o->loc+"spectrum");
o->osc->requestValue(o->loc+"waveform");

display->redraw();
}
void Oscilharmonic::cb_phase(OGSlider* o, void* v) {
  ((Oscilharmonic*)(o->parent()->user_data()))->cb_phase_i(o,v);
}

Fl_Osc_Group* Oscilharmonic::make_window() {
  { harmonic = new Fl_Osc_Group(0, 0, 100, 225);
    harmonic->box(FL_NO_BOX);
    harmonic->color(FL_BACKGROUND_COLOR);
    harmonic->selection_color(FL_BACKGROUND_COLOR);
    harmonic->labeltype(FL_NO_LABEL);
    harmonic->labelfont(0);
    harmonic->labelsize(14);
    harmonic->labelcolor(FL_FOREGROUND_COLOR);
    harmonic->user_data((void*)(this));
    harmonic->align(Fl_Align(FL_ALIGN_TOP));
    harmonic->when(FL_WHEN_RELEASE);
    { OGSlider* o = mag = new OGSlider(0, 15, 15, 115);
      mag->type(4);
      mag->box(FL_NO_BOX);
      mag->color(FL_BACKGROUND_COLOR);
      mag->selection_color((Fl_Color)222);
      mag->labeltype(FL_NORMAL_LABEL);
      mag->labelfont(0);
      mag->labelsize(14);
      mag->labelcolor(FL_FOREGROUND_COLOR);
      mag->maximum(127);
      mag->step(1);
      mag->value(64);
      mag->callback((Fl_Callback*)cb_mag);
      mag->align(Fl_Align(FL_ALIGN_BOTTOM));
      mag->when(FL_WHEN_CHANGED);
      o->phase=false;o->ext = "magnitude"+to_s(n);//o->value(127-oscil->Phmag[n]);
      //if (oscil->Phmag[n]==64) o->selection_color(0);
    } // OGSlider* mag
    { OGSlider* o = phase = new OGSlider(0, 135, 15, 75);
      phase->type(4);
      phase->box(FL_NO_BOX);
      phase->color(FL_BACKGROUND_COLOR);
      phase->selection_color((Fl_Color)222);
      phase->labeltype(FL_NORMAL_LABEL);
      phase->labelfont(0);
      phase->labelsize(14);
      phase->labelcolor(FL_FOREGROUND_COLOR);
      phase->maximum(127);
      phase->step(1);
      phase->value(64);
      phase->callback((Fl_Callback*)cb_phase);
      phase->align(Fl_Align(FL_ALIGN_BOTTOM));
      phase->when(FL_WHEN_CHANGED);
      o->phase=true;o->ext = "phase"+to_s(n);//o->value(oscil->Phphase[n]);
    } // OGSlider* phase
    { Fl_Box* o = new Fl_Box(15, 70, 5, 5);
      o->box(FL_FLAT_BOX);
      o->color(FL_DARK2);
    } // Fl_Box* o
    { Fl_Box* o = new Fl_Box(15, 170, 5, 5);
      o->box(FL_FLAT_BOX);
      o->color(FL_DARK2);
    } // Fl_Box* o
    { Fl_Box* o = new Fl_Box(0, 210, 20, 15, "01");
      o->labelfont(1);
      o->labelsize(9);
      o->align(Fl_Align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE));
      char tmp[10];snprintf(tmp,10,"%d",n+1);o->label(strdup(tmp));
    } // Fl_Box* o
    { Fl_Box* o = new Fl_Box(0, 0, 20, 15, "01");
      o->labelfont(1);
      o->labelsize(9);
      o->align(Fl_Align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE));
      char tmp[10];snprintf(tmp,10,"%d",n+1);o->label(strdup(tmp));
    } // Fl_Box* o
    harmonic->end();
  } // Fl_Osc_Group* harmonic
  return harmonic;
}

Oscilharmonic::Oscilharmonic(int x,int y, int w, int h, const char *label):Fl_Group(x,y,w,h,label) {
  n=0;
  display=NULL;
}

void Oscilharmonic::init(int n_,Fl_Group *display_, std::string loc_, Fl_Osc_Interface *osc_) {
  assert(osc_);
  assert(!loc_.empty());
  
  n=n_;
  display=display_;
  osc = osc_;
  loc = loc_;
  make_window();
  mag->osc = osc;
  mag->loc = loc;
  mag->reset_value = 63;
  mag->set_transform([](float x){return 63.0f - x;});
  phase->osc = osc;
  phase->loc = loc;
  phase->reset_value = 64;
  phase->set_rounding(1);
  phase->set_transform([](float x){return 180*(1 - x/64.0f);});
  
  osc->createLink(loc+"magnitude"+to_s(n), mag);
  osc->createLink(loc+"phase"+to_s(n), phase);
  osc->requestValue(loc+"magnitude"+to_s(n));
  osc->requestValue(loc+"phase"+to_s(n));
  end();
  harmonic->show();
}

void Oscilharmonic::refresh() {
  osc->requestValue(loc+"magnitude"+to_s(n));//mag->value(127-oscil->Phmag[n]);
  osc->requestValue(loc+"phase"+to_s(n));//phase->value(oscil->Phphase[n]);
}

Oscilharmonic::~Oscilharmonic() {
  osc->removeLink(loc+"magnitude"+to_s(n), mag);
  osc->removeLink(loc+"phase"+to_s(n), phase);
  
  harmonic->hide();
  delete harmonic;
}

void OscilEditor::cb_applybutton_i(Fl_Button*, void*) {
  dummy->osc->requestValue(loc+"../prepare");
}
void OscilEditor::cb_applybutton(Fl_Button* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->user_data()))->cb_applybutton_i(o,v);
}

Fl_Menu_Item OscilEditor::menu_hrndtype[] = {
 {"None", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"Pow", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"Sin", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {0,0,0,0,0,0,0,0,0}
};

void OscilEditor::cb_magtype_i(Fl_Osc_Choice*, void*) {
  redrawoscil();
}
void OscilEditor::cb_magtype(Fl_Osc_Choice* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->user_data()))->cb_magtype_i(o,v);
}

Fl_Menu_Item OscilEditor::menu_magtype[] = {
 {"Linear", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 11, 0},
 {"-40dB", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 11, 0},
 {"-60dB", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 11, 0},
 {"-80dB", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 11, 0},
 {"-100dB", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 11, 0},
 {0,0,0,0,0,0,0,0,0}
};

void OscilEditor::cb_bfpar_i(Fl_Osc_Dial* o, void*) {
  redrawoscil(); if(bfparval){bfparval->value(o->value());};
}
void OscilEditor::cb_bfpar(Fl_Osc_Dial* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->user_data()))->cb_bfpar_i(o,v);
}

void OscilEditor::cb_bftype_i(OGWaveChoice* o, void*) {
  basefuncdisplaygroup->redraw();
redrawoscil();

if(!basefuncmodulation) return;
setbfmodstatus(o->value());
}
void OscilEditor::cb_bftype(OGWaveChoice* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->user_data()))->cb_bftype_i(o,v);
}

Fl_Menu_Item OscilEditor::menu_bftype[] = {
 {"Sine", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 11, 0},
 {"Triangle", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 11, 0},
 {"Pulse", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 11, 0},
 {"Saw", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 11, 0},
 {"Power", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 11, 0},
 {"Gauss", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 11, 0},
 {"Diode", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 11, 0},
 {"AbsSine", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 11, 0},
 {"PulseSine", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 11, 0},
 {"StrchSine", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 11, 0},
 {"Chirp", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 11, 0},
 {"AbsStrSine", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 11, 0},
 {"Chebyshev", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 11, 0},
 {"Sqr", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 11, 0},
 {"Spike", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 11, 0},
 {"Circle", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 11, 0},
 {"User", 0,  0, 0, 16, FL_NORMAL_LABEL, 1, 11, 0},
 {0,0,0,0,0,0,0,0,0}
};

void OscilEditor::cb_bfmodtype_i(Fl_Osc_Choice*, void*) {
  basefuncdisplaygroup->redraw();
redrawoscil();
}
void OscilEditor::cb_bfmodtype(Fl_Osc_Choice* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_bfmodtype_i(o,v);
}

Fl_Menu_Item OscilEditor::menu_bfmodtype[] = {
 {"None", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"Rev", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"Sine", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"Pow", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"Chop", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {0,0,0,0,0,0,0,0,0}
};

void OscilEditor::cb_bfmodpar1_i(Fl_Osc_Dial*, void*) {
  redrawoscil();
}
void OscilEditor::cb_bfmodpar1(Fl_Osc_Dial* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_bfmodpar1_i(o,v);
}

void OscilEditor::cb_bfmodpar2_i(Fl_Osc_Dial*, void*) {
  redrawoscil();
}
void OscilEditor::cb_bfmodpar2(Fl_Osc_Dial* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_bfmodpar2_i(o,v);
}

void OscilEditor::cb_bfmodpar3_i(Fl_Osc_Dial*, void*) {
  redrawoscil();
}
void OscilEditor::cb_bfmodpar3(Fl_Osc_Dial* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_bfmodpar3_i(o,v);
}

void OscilEditor::cb_Use_i(Fl_Button*, void*) {
  osc->requestValue(loc+"use-as-base");
if (autoclearbutton->value()){
   for (int i=1;i<(MAX_AD_HARMONICS - 1);i++){
      h[i]->mag->value(63);
      h[i]->mag->do_callback();
      h[i]->phase->value(64);
      h[i]->phase->do_callback();
   };

   harmonicshiftcounter->value(0);

   h[0]->mag->value(0);
   h[0]->mag->do_callback();
   h[0]->phase->value(64);
   h[0]->phase->do_callback();
   wshbutton->value(0);
   wshbutton->do_callback();
   fltbutton->value(0);
   fltbutton->do_callback();
   sabutton->value(0);
   sabutton->do_callback();
   bfmodtype->value(0);
   bfmodtype->do_callback();
};

 osc->requestValue(loc+"prepare");
 bftype->update();

basefuncdisplaygroup->redraw();
redrawoscil();
}
void OscilEditor::cb_Use(Fl_Button* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->user_data()))->cb_Use_i(o,v);
}

void OscilEditor::cb_Close_i(Fl_Button*, void*) {
  osceditUI->hide();
}
void OscilEditor::cb_Close(Fl_Button* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->user_data()))->cb_Close_i(o,v);
}

void OscilEditor::cb_Clear_i(Fl_Button*, void*) {
  if (!fl_choice("Clear the harmonics settings?","No","Yes",NULL)) return;

for (int i=1;i<(MAX_AD_HARMONICS - 1);i++){
    h[i]->mag->value(63);
    h[i]->mag->do_callback();
    h[i]->phase->value(64);
    h[i]->phase->do_callback();
};
h[0]->mag->value(0);
h[0]->mag->do_callback();
h[0]->phase->value(64);
h[0]->phase->do_callback();

//harmonics->redraw();
osc->requestValue(loc+"prepare");
redrawoscil();
}
void OscilEditor::cb_Clear(Fl_Button* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->user_data()))->cb_Clear_i(o,v);
}

void OscilEditor::cb_wshbutton_i(Fl_Osc_Choice*, void*) {
  basefuncdisplaygroup->redraw();
redrawoscil();
}
void OscilEditor::cb_wshbutton(Fl_Osc_Choice* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->user_data()))->cb_wshbutton_i(o,v);
}

Fl_Menu_Item OscilEditor::menu_wshbutton[] = {
 {"None", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"Atan", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"Asym1", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"Pow", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"Sine", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"Qnts", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"Zigzg", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"Lmt", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"LmtU", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"LmtL", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"ILmt", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"Clip", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"Asym2", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"Pow2", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"Sgm", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {0,0,0,0,0,0,0,0,0}
};

void OscilEditor::cb_wshpar_i(Fl_Osc_Dial* o, void*) {
  redrawoscil();if(wsparval){wsparval->value(o->value());};
}
void OscilEditor::cb_wshpar(Fl_Osc_Dial* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->user_data()))->cb_wshpar_i(o,v);
}

void OscilEditor::cb_fltbutton_i(Fl_Osc_Choice*, void*) {
  redrawoscil();
}
void OscilEditor::cb_fltbutton(Fl_Osc_Choice* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->user_data()))->cb_fltbutton_i(o,v);
}

Fl_Menu_Item OscilEditor::menu_fltbutton[] = {
 {"None", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"LP1", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"HP1a", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"HP1b", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"BP1", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"BS1", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"LP2", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"HP2", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"BP2", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"BS2", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"Cos", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"Sin", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"LSh", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"S", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {0,0,0,0,0,0,0,0,0}
};

void OscilEditor::cb_filtervalue1_i(Fl_Osc_Dial*, void*) {
  redrawoscil();
}
void OscilEditor::cb_filtervalue1(Fl_Osc_Dial* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->user_data()))->cb_filtervalue1_i(o,v);
}

void OscilEditor::cb_filterpref_i(Fl_Check_Button*, void*) {
  redrawoscil();
}
void OscilEditor::cb_filterpref(Fl_Check_Button* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->user_data()))->cb_filterpref_i(o,v);
}

void OscilEditor::cb_filtervalue2_i(Fl_Osc_Dial*, void*) {
  redrawoscil();
}
void OscilEditor::cb_filtervalue2(Fl_Osc_Dial* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->user_data()))->cb_filtervalue2_i(o,v);
}

void OscilEditor::cb_sabutton_i(Fl_Osc_Choice*, void*) {
  redrawoscil();
}
void OscilEditor::cb_sabutton(Fl_Osc_Choice* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->user_data()))->cb_sabutton_i(o,v);
}

Fl_Menu_Item OscilEditor::menu_sabutton[] = {
 {"None", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"Pow", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"ThrsD", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"ThrsU", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {0,0,0,0,0,0,0,0,0}
};

void OscilEditor::cb_sadjpar_i(Fl_Osc_Dial*, void*) {
  redrawoscil();
}
void OscilEditor::cb_sadjpar(Fl_Osc_Dial* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->user_data()))->cb_sadjpar_i(o,v);
}

void OscilEditor::cb_harmonicshiftcounter_i(Fl_Osc_Counter*, void*) {
  redrawoscil();
}
void OscilEditor::cb_harmonicshiftcounter(Fl_Osc_Counter* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->user_data()))->cb_harmonicshiftcounter_i(o,v);
}

void OscilEditor::cb_harmonicshiftpre_i(Fl_Osc_Check*, void*) {
  redrawoscil();
}
void OscilEditor::cb_harmonicshiftpre(Fl_Osc_Check* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->user_data()))->cb_harmonicshiftpre_i(o,v);
}

void OscilEditor::cb_R_i(Fl_Button*, void*) {
  //oscil->Pharmonicshift=0;
harmonicshiftcounter->value(0);
redrawoscil();
}
void OscilEditor::cb_R(Fl_Button* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->user_data()))->cb_R_i(o,v);
}

void OscilEditor::cb_adhrtype_i(Fl_Osc_Choice*, void*) {
  redrawoscil();
}
void OscilEditor::cb_adhrtype(Fl_Osc_Choice* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->user_data()))->cb_adhrtype_i(o,v);
}

Fl_Menu_Item OscilEditor::menu_adhrtype[] = {
 {"OFF", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"ON", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"Square", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"2xSub", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"2xAdd", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"3xSub", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"3xAdd", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"4xSub", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"4xAdd", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {0,0,0,0,0,0,0,0,0}
};

void OscilEditor::cb_adhrpow_i(Fl_Osc_Dial*, void*) {
  redrawoscil();
}
void OscilEditor::cb_adhrpow(Fl_Osc_Dial* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->user_data()))->cb_adhrpow_i(o,v);
}

void OscilEditor::cb_adhrbf_i(Fl_Osc_Dial*, void*) {
  redrawoscil();
}
void OscilEditor::cb_adhrbf(Fl_Osc_Dial* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->user_data()))->cb_adhrbf_i(o,v);
}

void OscilEditor::cb_adhrpar_i(Fl_Osc_TSlider*, void*) {
  redrawoscil();
}
void OscilEditor::cb_adhrpar(Fl_Osc_TSlider* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->user_data()))->cb_adhrpar_i(o,v);
}

void OscilEditor::cb_modtype_i(Fl_Osc_Choice*, void*) {
  redrawoscil();
}
void OscilEditor::cb_modtype(Fl_Osc_Choice* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->user_data()))->cb_modtype_i(o,v);
}

Fl_Menu_Item OscilEditor::menu_modtype[] = {
 {"None", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"Rev", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"Sine", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"Pow", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {0,0,0,0,0,0,0,0,0}
};

void OscilEditor::cb_modpar1_i(Fl_Osc_Dial*, void*) {
  redrawoscil();
}
void OscilEditor::cb_modpar1(Fl_Osc_Dial* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->user_data()))->cb_modpar1_i(o,v);
}

void OscilEditor::cb_modpar2_i(Fl_Osc_Dial*, void*) {
  redrawoscil();
}
void OscilEditor::cb_modpar2(Fl_Osc_Dial* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->user_data()))->cb_modpar2_i(o,v);
}

void OscilEditor::cb_modpar3_i(Fl_Osc_Dial*, void*) {
  redrawoscil();
}
void OscilEditor::cb_modpar3(Fl_Osc_Dial* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->parent()->user_data()))->cb_modpar3_i(o,v);
}

void OscilEditor::cb_Sine_i(Fl_Button*, void*) {
  if (!fl_choice("Convert to SINE?","No","Yes",NULL)) return;

osc->requestValue(loc+"convert2sine");
bftype->update();
bfpar->value(0);
bfpar->do_callback();

redrawoscil();
refresh();
}
void OscilEditor::cb_Sine(Fl_Button* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->user_data()))->cb_Sine_i(o,v);
}

void OscilEditor::cb_C_i(Fl_Button*, void*) {
  presetsui->copy(dummy->loc());
}
void OscilEditor::cb_C(Fl_Button* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->user_data()))->cb_C_i(o,v);
}

void OscilEditor::cb_P_i(Fl_Button*, void*) {
  presetsui->paste(dummy->loc(), this);
}
void OscilEditor::cb_P(Fl_Button* o, void* v) {
  ((OscilEditor*)(o->parent()->parent()->user_data()))->cb_P_i(o,v);
}

Fl_Double_Window* OscilEditor::make_window() {
  { Fl_Double_Window* o = osceditUI = new Fl_Double_Window(735, 595, "ADsynth Oscillator Editor");
    osceditUI->user_data((void*)(this));
    { dummy = new Fl_Osc_Group(0, 0, 735, 595);
      dummy->box(FL_FLAT_BOX);
      dummy->color(FL_BACKGROUND_COLOR);
      dummy->selection_color(FL_BACKGROUND_COLOR);
      dummy->labeltype(FL_NORMAL_LABEL);
      dummy->labelfont(0);
      dummy->labelsize(14);
      dummy->labelcolor(FL_FOREGROUND_COLOR);
      dummy->align(Fl_Align(FL_ALIGN_TOP));
      dummy->when(FL_WHEN_RELEASE);
      { Fl_Button* o = applybutton = new Fl_Button(305, 285, 60, 20, "Apply");
        applybutton->box(FL_THIN_UP_BOX);
        applybutton->labelfont(1);
        applybutton->callback((Fl_Callback*)cb_applybutton);
        if(adnotep) o->hide();
        dummy->base = loc;
        dummy->osc = osc;
      } // Fl_Button* applybutton
      { oscildisplaygroup = new Fl_Group(10, 10, 360, 300);
        oscildisplaygroup->box(FL_UP_FRAME);
        { Fl_Group* o = new Fl_Group(15, 90, 350, 190);
          o->box(FL_THIN_DOWN_BOX);
          o->color(FL_GRAY0);
          o->selection_color((Fl_Color)71);
          o->labelcolor((Fl_Color)179);
          oscilo=new Fl_Oscilloscope(o->x(),o->y(),o->w(),o->h(),"");
          oscilo->parent(o);oscilo->init(false);
          o->end();
        } // Fl_Group* o
        { Fl_Box* o = new Fl_Box(125, 15, 110, 20, "Oscillator");
          o->labelfont(1);
        } // Fl_Box* o
        { Fl_Osc_VSlider* o = rndslider = new Fl_Osc_VSlider(145, 290, 100, 10, "rnd");
          rndslider->tooltip("Oscilator Phase Randomness: smaller than 0 is \"group\", larger than 0 is for\
 each harmonic");
          rndslider->type(5);
          rndslider->box(FL_NO_BOX);
          rndslider->color(FL_BACKGROUND_COLOR);
          rndslider->selection_color(FL_BACKGROUND_COLOR);
          rndslider->labeltype(FL_NORMAL_LABEL);
          rndslider->labelfont(0);
          rndslider->labelsize(10);
          rndslider->labelcolor(FL_FOREGROUND_COLOR);
          rndslider->minimum(-64);
          rndslider->maximum(63);
          rndslider->step(1);
          rndslider->align(Fl_Align(FL_ALIGN_TOP_LEFT));
          rndslider->when(FL_WHEN_CHANGED);
          (void)o->init("Prand"); if (!adnotep) o->hide();
        } // Fl_Osc_VSlider* rndslider
        { Fl_Group* o = new Fl_Group(15, 35, 350, 50);
          o->box(FL_THIN_DOWN_BOX);
          o->color(FL_GRAY0);
          o->selection_color((Fl_Color)218);
          o->labelcolor(FL_GREEN);
          oscils=new Fl_OscilSpectrum(o->x(),o->y(),o->w(),o->h(),"");
          oscils->parent(o);oscils->init(false);
          o->end();
        } // Fl_Group* o
        { Fl_Group* o = new Fl_Group(251, 282, 115, 25);
          o->box(FL_UP_FRAME);
          { Fl_Osc_Choice* o = hrndtype = new Fl_Osc_Choice(286, 287, 50, 15, "H.rnd");
            hrndtype->tooltip("Harmonic Amplitude Randomness");
            hrndtype->box(FL_UP_BOX);
            hrndtype->down_box(FL_BORDER_BOX);
            hrndtype->color(FL_BACKGROUND_COLOR);
            hrndtype->selection_color(FL_SELECTION_COLOR);
            hrndtype->labeltype(FL_NORMAL_LABEL);
            hrndtype->labelfont(0);
            hrndtype->labelsize(10);
            hrndtype->labelcolor(FL_FOREGROUND_COLOR);
            hrndtype->textsize(10);
            hrndtype->align(Fl_Align(FL_ALIGN_LEFT));
            hrndtype->when(FL_WHEN_RELEASE);
            hrndtype->menu(menu_hrndtype);
            o->init("Pamprandtype");
          } // Fl_Osc_Choice* hrndtype
          { Fl_Osc_Dial* o = hrnddial = new Fl_Osc_Dial(345, 285, 18, 18);
            hrnddial->tooltip("Oscillator\'s spectrum adjust parameter");
            hrnddial->box(FL_NO_BOX);
            hrnddial->color(FL_BACKGROUND_COLOR);
            hrnddial->selection_color(FL_INACTIVE_COLOR);
            hrnddial->labeltype(FL_NORMAL_LABEL);
            hrnddial->labelfont(0);
            hrnddial->labelsize(14);
            hrnddial->labelcolor(FL_FOREGROUND_COLOR);
            hrnddial->maximum(127);
            hrnddial->step(1);
            hrnddial->align(Fl_Align(FL_ALIGN_BOTTOM));
            hrnddial->when(FL_WHEN_CHANGED);
            o->init("Pamprandpower");o->reset_value=64;
          } // Fl_Osc_Dial* hrnddial
          if (!adnotep) o->hide();
          o->end();
        } // Fl_Group* o
        { Fl_Osc_Choice* o = magtype = new Fl_Osc_Choice(75, 285, 65, 20, "Mag.Type");
          magtype->box(FL_UP_BOX);
          magtype->down_box(FL_BORDER_BOX);
          magtype->color(FL_BACKGROUND_COLOR);
          magtype->selection_color(FL_SELECTION_COLOR);
          magtype->labeltype(FL_NORMAL_LABEL);
          magtype->labelfont(0);
          magtype->labelsize(11);
          magtype->labelcolor(FL_FOREGROUND_COLOR);
          magtype->textsize(11);
          magtype->callback((Fl_Callback*)cb_magtype);
          magtype->align(Fl_Align(FL_ALIGN_LEFT));
          magtype->when(FL_WHEN_CHANGED);
          magtype->menu(menu_magtype);
          o->init("Phmagtype");
        } // Fl_Osc_Choice* magtype
        oscildisplaygroup->end();
      } // Fl_Group* oscildisplaygroup
      { Fl_Osc_Group* o = basefuncdisplaygroup = new Fl_Osc_Group(370, 10, 360, 300);
        basefuncdisplaygroup->box(FL_UP_FRAME);
        basefuncdisplaygroup->color(FL_BACKGROUND_COLOR);
        basefuncdisplaygroup->selection_color(FL_BACKGROUND_COLOR);
        basefuncdisplaygroup->labeltype(FL_NORMAL_LABEL);
        basefuncdisplaygroup->labelfont(0);
        basefuncdisplaygroup->labelsize(14);
        basefuncdisplaygroup->labelcolor(FL_FOREGROUND_COLOR);
        basefuncdisplaygroup->align(Fl_Align(FL_ALIGN_TOP));
        basefuncdisplaygroup->when(FL_WHEN_RELEASE);
        { Fl_Group* o = new Fl_Group(375, 90, 350, 190);
          o->box(FL_THIN_DOWN_BOX);
          o->color(FL_GRAY0);
          o->selection_color((Fl_Color)71);
          o->labelcolor((Fl_Color)179);
          oscilo_base=new Fl_Oscilloscope(o->x(),o->y(),o->w(),o->h(),"");
          oscilo_base->parent(o);oscilo_base->init(true);
          o->end();
        } // Fl_Group* o
        { Fl_Osc_Dial* o = bfpar = new Fl_Osc_Dial(525, 285, 20, 20);
          bfpar->tooltip("Base Function Parameter");
          bfpar->box(FL_NO_BOX);
          bfpar->color(FL_BACKGROUND_COLOR);
          bfpar->selection_color(FL_INACTIVE_COLOR);
          bfpar->labeltype(FL_NORMAL_LABEL);
          bfpar->labelfont(0);
          bfpar->labelsize(14);
          bfpar->labelcolor(FL_FOREGROUND_COLOR);
          bfpar->minimum(-64);
          bfpar->maximum(63);
          bfpar->step(1);
          bfpar->callback((Fl_Callback*)cb_bfpar);
          bfpar->align(Fl_Align(FL_ALIGN_BOTTOM));
          bfpar->when(FL_WHEN_CHANGED);
          o->init("Pbasefuncpar");
        } // Fl_Osc_Dial* bfpar
        { bftype = new OGWaveChoice(375, 290, 90, 15, "Base.F..");
          bftype->box(FL_UP_BOX);
          bftype->down_box(FL_BORDER_BOX);
          bftype->color(FL_BACKGROUND_COLOR);
          bftype->selection_color(FL_SELECTION_COLOR);
          bftype->labeltype(FL_NORMAL_LABEL);
          bftype->labelfont(0);
          bftype->labelsize(10);
          bftype->labelcolor(FL_FOREGROUND_COLOR);
          bftype->textsize(11);
          bftype->callback((Fl_Callback*)cb_bftype);
          bftype->align(Fl_Align(FL_ALIGN_TOP_LEFT));
          bftype->when(FL_WHEN_CHANGED);
          bftype->menu(menu_bftype);
        } // OGWaveChoice* bftype
        { Fl_Box* o = new Fl_Box(485, 15, 110, 20, "Base Func.");
          o->labelfont(1);
        } // Fl_Box* o
        { Fl_Group* o = new Fl_Group(375, 35, 350, 50);
          o->box(FL_THIN_DOWN_BOX);
          o->color(FL_GRAY0);
          o->selection_color((Fl_Color)218);
          o->labelcolor(FL_GREEN);
          oscils_base=new Fl_OscilSpectrum (o->x(),o->y(),o->w(),o->h(),"");
          oscils_base->parent(o);oscils_base->init(true);
          o->end();
        } // Fl_Group* o
        { Fl_Value_Output* o = bfparval = new Fl_Value_Output(495, 290, 25, 15, "Par.");
          bfparval->labelsize(12);
          bfparval->minimum(-63);
          bfparval->maximum(63);
          bfparval->step(1);
          o->value(bfpar->value());
        } // Fl_Value_Output* bfparval
        { basefuncmodulation = new Fl_Group(555, 281, 169, 25);
          basefuncmodulation->box(FL_UP_FRAME);
          { Fl_Osc_Choice* o = bfmodtype = new Fl_Osc_Choice(604, 286, 50, 15, "B.F.Mod.");
            bfmodtype->tooltip("Base function modulation");
            bfmodtype->box(FL_UP_BOX);
            bfmodtype->down_box(FL_BORDER_BOX);
            bfmodtype->color(FL_BACKGROUND_COLOR);
            bfmodtype->selection_color(FL_SELECTION_COLOR);
            bfmodtype->labeltype(FL_NORMAL_LABEL);
            bfmodtype->labelfont(0);
            bfmodtype->labelsize(10);
            bfmodtype->labelcolor(FL_FOREGROUND_COLOR);
            bfmodtype->textsize(10);
            bfmodtype->callback((Fl_Callback*)cb_bfmodtype);
            bfmodtype->align(Fl_Align(FL_ALIGN_LEFT));
            bfmodtype->when(FL_WHEN_CHANGED);
            bfmodtype->menu(menu_bfmodtype);
            o->init("Pbasefuncmodulation");
          } // Fl_Osc_Choice* bfmodtype
          { Fl_Osc_Dial* o = bfmodpar1 = new Fl_Osc_Dial(664, 286, 15, 15);
            bfmodpar1->tooltip("Oscillator\'s modulation parameter 1");
            bfmodpar1->box(FL_NO_BOX);
            bfmodpar1->color(FL_BACKGROUND_COLOR);
            bfmodpar1->selection_color(FL_INACTIVE_COLOR);
            bfmodpar1->labeltype(FL_NORMAL_LABEL);
            bfmodpar1->labelfont(0);
            bfmodpar1->labelsize(14);
            bfmodpar1->labelcolor(FL_FOREGROUND_COLOR);
            bfmodpar1->maximum(127);
            bfmodpar1->step(1);
            bfmodpar1->callback((Fl_Callback*)cb_bfmodpar1);
            bfmodpar1->align(Fl_Align(FL_ALIGN_BOTTOM));
            bfmodpar1->when(FL_WHEN_CHANGED);
            o->init("Pbasefuncmodulationpar1");o->reset_value=64;
          } // Fl_Osc_Dial* bfmodpar1
          { Fl_Osc_Dial* o = bfmodpar2 = new Fl_Osc_Dial(684, 286, 15, 15);
            bfmodpar2->tooltip("Oscillator\'s modulation parameter 2");
            bfmodpar2->box(FL_NO_BOX);
            bfmodpar2->color(FL_BACKGROUND_COLOR);
            bfmodpar2->selection_color(FL_INACTIVE_COLOR);
            bfmodpar2->labeltype(FL_NORMAL_LABEL);
            bfmodpar2->labelfont(0);
            bfmodpar2->labelsize(14);
            bfmodpar2->labelcolor(FL_FOREGROUND_COLOR);
            bfmodpar2->maximum(127);
            bfmodpar2->step(1);
            bfmodpar2->callback((Fl_Callback*)cb_bfmodpar2);
            bfmodpar2->align(Fl_Align(FL_ALIGN_BOTTOM));
            bfmodpar2->when(FL_WHEN_CHANGED);
            o->init("Pbasefuncmodulationpar2");o->reset_value=64;
          } // Fl_Osc_Dial* bfmodpar2
          { Fl_Osc_Dial* o = bfmodpar3 = new Fl_Osc_Dial(704, 286, 15, 15);
            bfmodpar3->tooltip("Oscillator\'s modulation parameter 3");
            bfmodpar3->box(FL_NO_BOX);
            bfmodpar3->color(FL_BACKGROUND_COLOR);
            bfmodpar3->selection_color(FL_INACTIVE_COLOR);
            bfmodpar3->labeltype(FL_NORMAL_LABEL);
            bfmodpar3->labelfont(0);
            bfmodpar3->labelsize(14);
            bfmodpar3->labelcolor(FL_FOREGROUND_COLOR);
            bfmodpar3->maximum(127);
            bfmodpar3->step(1);
            bfmodpar3->callback((Fl_Callback*)cb_bfmodpar3);
            bfmodpar3->align(Fl_Align(FL_ALIGN_BOTTOM));
            bfmodpar3->when(FL_WHEN_CHANGED);
            o->init("Pbasefuncmodulationpar3");o->reset_value=32;
          } // Fl_Osc_Dial* bfmodpar3
          basefuncmodulation->end();
        } // Fl_Group* basefuncmodulation
        o->base = loc;
        o->osc = osc; bftype->ogui = this;
        assert(osc);
        basefuncdisplaygroup->end();
      } // Fl_Osc_Group* basefuncdisplaygroup
      { Fl_Button* o = new Fl_Button(10, 318, 85, 20, "Use as base");
        o->tooltip("Use this Oscillator as base function");
        o->box(FL_THIN_UP_BOX);
        o->labelfont(1);
        o->labelsize(11);
        o->callback((Fl_Callback*)cb_Use);
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(673, 570, 62, 25, "Close");
        o->box(FL_THIN_UP_BOX);
        o->callback((Fl_Callback*)cb_Close);
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(675, 510, 55, 15, "Clear");
        o->box(FL_THIN_UP_BOX);
        o->labelfont(1);
        o->labelsize(11);
        o->callback((Fl_Callback*)cb_Clear);
      } // Fl_Button* o
      { Fl_Group* o = new Fl_Group(140, 313, 150, 30);
        o->box(FL_UP_FRAME);
        { Fl_Osc_Choice* o = wshbutton = new Fl_Osc_Choice(170, 320, 55, 20, "Wsh.");
          wshbutton->tooltip("Waveshaping function");
          wshbutton->box(FL_UP_BOX);
          wshbutton->down_box(FL_BORDER_BOX);
          wshbutton->color(FL_BACKGROUND_COLOR);
          wshbutton->selection_color(FL_SELECTION_COLOR);
          wshbutton->labeltype(FL_NORMAL_LABEL);
          wshbutton->labelfont(0);
          wshbutton->labelsize(10);
          wshbutton->labelcolor(FL_FOREGROUND_COLOR);
          wshbutton->textsize(10);
          wshbutton->callback((Fl_Callback*)cb_wshbutton);
          wshbutton->align(Fl_Align(FL_ALIGN_LEFT));
          wshbutton->when(FL_WHEN_CHANGED);
          wshbutton->menu(menu_wshbutton);
          o->init("Pwaveshapingfunction");
        } // Fl_Osc_Choice* wshbutton
        { Fl_Osc_Dial* o = wshpar = new Fl_Osc_Dial(265, 318, 20, 20);
          wshpar->tooltip("Waveshaping Parameter");
          wshpar->box(FL_NO_BOX);
          wshpar->color(FL_BACKGROUND_COLOR);
          wshpar->selection_color(FL_INACTIVE_COLOR);
          wshpar->labeltype(FL_NORMAL_LABEL);
          wshpar->labelfont(0);
          wshpar->labelsize(14);
          wshpar->labelcolor(FL_FOREGROUND_COLOR);
          wshpar->minimum(-64);
          wshpar->maximum(63);
          wshpar->step(1);
          wshpar->callback((Fl_Callback*)cb_wshpar);
          wshpar->align(Fl_Align(FL_ALIGN_BOTTOM));
          wshpar->when(FL_WHEN_CHANGED);
          o->init("Pwaveshaping");
        } // Fl_Osc_Dial* wshpar
        { Fl_Value_Output* o = wsparval = new Fl_Value_Output(233, 321, 25, 15);
          wsparval->labelsize(12);
          wsparval->minimum(-63);
          wsparval->maximum(63);
          wsparval->step(1);
          o->value(wshpar->value());
        } // Fl_Value_Output* wsparval
        o->end();
      } // Fl_Group* o
      { autoclearbutton = new Fl_Check_Button(98, 318, 40, 20, "Clr.");
        autoclearbutton->tooltip("Auto clear when using the oscillator as base function");
        autoclearbutton->box(FL_THIN_UP_BOX);
        autoclearbutton->down_box(FL_DOWN_BOX);
        autoclearbutton->value(1);
        autoclearbutton->labelfont(1);
        autoclearbutton->labelsize(10);
      } // Fl_Check_Button* autoclearbutton
      { Fl_Group* o = new Fl_Group(290, 313, 155, 30);
        o->box(FL_UP_FRAME);
        { Fl_Osc_Choice* o = fltbutton = new Fl_Osc_Choice(320, 318, 50, 20, "Filter");
          fltbutton->tooltip("Oscillator\'s filter type");
          fltbutton->box(FL_UP_BOX);
          fltbutton->down_box(FL_BORDER_BOX);
          fltbutton->color(FL_BACKGROUND_COLOR);
          fltbutton->selection_color(FL_SELECTION_COLOR);
          fltbutton->labeltype(FL_NORMAL_LABEL);
          fltbutton->labelfont(0);
          fltbutton->labelsize(10);
          fltbutton->labelcolor(FL_FOREGROUND_COLOR);
          fltbutton->textsize(10);
          fltbutton->callback((Fl_Callback*)cb_fltbutton);
          fltbutton->align(Fl_Align(FL_ALIGN_LEFT));
          fltbutton->when(FL_WHEN_CHANGED);
          fltbutton->menu(menu_fltbutton);
          o->init("Pfiltertype");
        } // Fl_Osc_Choice* fltbutton
        { Fl_Osc_Dial* o = filtervalue1 = new Fl_Osc_Dial(372, 318, 20, 20);
          filtervalue1->tooltip("Oscillator\'s filter parameter1");
          filtervalue1->box(FL_NO_BOX);
          filtervalue1->color(FL_BACKGROUND_COLOR);
          filtervalue1->selection_color(FL_INACTIVE_COLOR);
          filtervalue1->labeltype(FL_NORMAL_LABEL);
          filtervalue1->labelfont(0);
          filtervalue1->labelsize(14);
          filtervalue1->labelcolor(FL_FOREGROUND_COLOR);
          filtervalue1->maximum(127);
          filtervalue1->step(1);
          filtervalue1->callback((Fl_Callback*)cb_filtervalue1);
          filtervalue1->align(Fl_Align(FL_ALIGN_BOTTOM));
          filtervalue1->when(FL_WHEN_CHANGED);
          o->init("Pfilterpar1");o->reset_value=64;
        } // Fl_Osc_Dial* filtervalue1
        { filterpref = new Fl_Check_Button(420, 318, 20, 20, "p");
          filterpref->tooltip("Apply the filter before the waveshaping");
          filterpref->down_box(FL_DOWN_BOX);
          filterpref->labelsize(10);
          filterpref->callback((Fl_Callback*)cb_filterpref);
          filterpref->align(Fl_Align(FL_ALIGN_RIGHT|FL_ALIGN_INSIDE));
        } // Fl_Check_Button* filterpref
        { Fl_Osc_Dial* o = filtervalue2 = new Fl_Osc_Dial(395, 318, 20, 20);
          filtervalue2->tooltip("Oscillator\'s filter parameter2");
          filtervalue2->box(FL_NO_BOX);
          filtervalue2->color(FL_BACKGROUND_COLOR);
          filtervalue2->selection_color(FL_INACTIVE_COLOR);
          filtervalue2->labeltype(FL_NORMAL_LABEL);
          filtervalue2->labelfont(0);
          filtervalue2->labelsize(14);
          filtervalue2->labelcolor(FL_FOREGROUND_COLOR);
          filtervalue2->maximum(127);
          filtervalue2->step(1);
          filtervalue2->callback((Fl_Callback*)cb_filtervalue2);
          filtervalue2->align(Fl_Align(FL_ALIGN_BOTTOM));
          filtervalue2->when(FL_WHEN_CHANGED);
          o->init("Pfilterpar2");o->reset_value=64;
        } // Fl_Osc_Dial* filtervalue2
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(595, 313, 135, 30);
        o->box(FL_UP_FRAME);
        { Fl_Osc_Choice* o = sabutton = new Fl_Osc_Choice(635, 318, 60, 20, "Sp.adj.");
          sabutton->tooltip("Oscillator\'s spectrum adjust");
          sabutton->box(FL_UP_BOX);
          sabutton->down_box(FL_BORDER_BOX);
          sabutton->color(FL_BACKGROUND_COLOR);
          sabutton->selection_color(FL_SELECTION_COLOR);
          sabutton->labeltype(FL_NORMAL_LABEL);
          sabutton->labelfont(0);
          sabutton->labelsize(10);
          sabutton->labelcolor(FL_FOREGROUND_COLOR);
          sabutton->textsize(10);
          sabutton->callback((Fl_Callback*)cb_sabutton);
          sabutton->align(Fl_Align(FL_ALIGN_LEFT));
          sabutton->when(FL_WHEN_CHANGED);
          sabutton->menu(menu_sabutton);
          o->init("Psatype");
        } // Fl_Osc_Choice* sabutton
        { Fl_Osc_Dial* o = sadjpar = new Fl_Osc_Dial(700, 318, 20, 20);
          sadjpar->tooltip("Oscillator\'s spectrum adjust parameter");
          sadjpar->box(FL_NO_BOX);
          sadjpar->color(FL_BACKGROUND_COLOR);
          sadjpar->selection_color(FL_INACTIVE_COLOR);
          sadjpar->labeltype(FL_NORMAL_LABEL);
          sadjpar->labelfont(0);
          sadjpar->labelsize(14);
          sadjpar->labelcolor(FL_FOREGROUND_COLOR);
          sadjpar->maximum(127);
          sadjpar->step(1);
          sadjpar->callback((Fl_Callback*)cb_sadjpar);
          sadjpar->align(Fl_Align(FL_ALIGN_BOTTOM));
          sadjpar->when(FL_WHEN_CHANGED);
          o->init("Psapar");o->reset_value=64;
        } // Fl_Osc_Dial* sadjpar
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(670, 345, 65, 65);
        o->box(FL_UP_FRAME);
        { Fl_Osc_Counter* o = harmonicshiftcounter = new Fl_Osc_Counter(675, 370, 55, 15, "Harmonic Shift");
          harmonicshiftcounter->type(1);
          harmonicshiftcounter->box(FL_UP_BOX);
          harmonicshiftcounter->color(FL_BACKGROUND_COLOR);
          harmonicshiftcounter->selection_color(FL_INACTIVE_COLOR);
          harmonicshiftcounter->labeltype(FL_NORMAL_LABEL);
          harmonicshiftcounter->labelfont(0);
          harmonicshiftcounter->labelsize(10);
          harmonicshiftcounter->labelcolor(FL_FOREGROUND_COLOR);
          harmonicshiftcounter->minimum(-64);
          harmonicshiftcounter->maximum(64);
          harmonicshiftcounter->step(1);
          harmonicshiftcounter->textfont(1);
          harmonicshiftcounter->textsize(10);
          harmonicshiftcounter->callback((Fl_Callback*)cb_harmonicshiftcounter);
          harmonicshiftcounter->align(Fl_Align(129));
          harmonicshiftcounter->when(FL_WHEN_CHANGED);
          o->init("Pharmonicshift");
        } // Fl_Osc_Counter* harmonicshiftcounter
        { Fl_Osc_Check* o = harmonicshiftpre = new Fl_Osc_Check(695, 390, 34, 15, "preH");
          harmonicshiftpre->tooltip("Apply the harmonic shift before the waveshaping and filtering");
          harmonicshiftpre->box(FL_NO_BOX);
          harmonicshiftpre->down_box(FL_DOWN_BOX);
          harmonicshiftpre->color(FL_BACKGROUND_COLOR);
          harmonicshiftpre->selection_color(FL_FOREGROUND_COLOR);
          harmonicshiftpre->labeltype(FL_NORMAL_LABEL);
          harmonicshiftpre->labelfont(0);
          harmonicshiftpre->labelsize(10);
          harmonicshiftpre->labelcolor(FL_FOREGROUND_COLOR);
          harmonicshiftpre->callback((Fl_Callback*)cb_harmonicshiftpre);
          harmonicshiftpre->align(Fl_Align(FL_ALIGN_RIGHT|FL_ALIGN_INSIDE));
          harmonicshiftpre->when(FL_WHEN_RELEASE);
          o->init("Pharmonicshiftfirst");
        } // Fl_Osc_Check* harmonicshiftpre
        { Fl_Button* o = new Fl_Button(675, 390, 20, 15, "R");
          o->box(FL_THIN_UP_BOX);
          o->labelfont(1);
          o->labelsize(10);
          o->callback((Fl_Callback*)cb_R);
        } // Fl_Button* o
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(670, 415, 65, 90);
        o->box(FL_UP_FRAME);
        { Fl_Osc_Choice* o = adhrtype = new Fl_Osc_Choice(675, 430, 55, 15, "Adpt.Harm.");
          adhrtype->tooltip("The type of the addaptive harmonics");
          adhrtype->box(FL_UP_BOX);
          adhrtype->down_box(FL_BORDER_BOX);
          adhrtype->color(FL_BACKGROUND_COLOR);
          adhrtype->selection_color(FL_SELECTION_COLOR);
          adhrtype->labeltype(FL_NORMAL_LABEL);
          adhrtype->labelfont(0);
          adhrtype->labelsize(10);
          adhrtype->labelcolor(FL_FOREGROUND_COLOR);
          adhrtype->textsize(10);
          adhrtype->callback((Fl_Callback*)cb_adhrtype);
          adhrtype->align(Fl_Align(129));
          adhrtype->when(3);
          adhrtype->menu(menu_adhrtype);
          o->init("Padaptiveharmonics");
        } // Fl_Osc_Choice* adhrtype
        { Fl_Osc_Dial* o = adhrpow = new Fl_Osc_Dial(705, 465, 25, 25, "pow");
          adhrpow->tooltip("Adaptive harmonics power");
          adhrpow->box(FL_NO_BOX);
          adhrpow->color(FL_BACKGROUND_COLOR);
          adhrpow->selection_color(FL_INACTIVE_COLOR);
          adhrpow->labeltype(FL_NORMAL_LABEL);
          adhrpow->labelfont(0);
          adhrpow->labelsize(10);
          adhrpow->labelcolor(FL_FOREGROUND_COLOR);
          adhrpow->maximum(200);
          adhrpow->step(1);
          adhrpow->callback((Fl_Callback*)cb_adhrpow);
          adhrpow->align(Fl_Align(FL_ALIGN_BOTTOM));
          adhrpow->when(FL_WHEN_CHANGED);
          o->init("Padaptiveharmonicspower");o->reset_value=100;
        } // Fl_Osc_Dial* adhrpow
        { Fl_Osc_Dial* o = adhrbf = new Fl_Osc_Dial(675, 465, 25, 25, "baseF");
          adhrbf->tooltip("Adaptive harmonics base frequency");
          adhrbf->box(FL_NO_BOX);
          adhrbf->color(FL_BACKGROUND_COLOR);
          adhrbf->selection_color(FL_INACTIVE_COLOR);
          adhrbf->labeltype(FL_NORMAL_LABEL);
          adhrbf->labelfont(0);
          adhrbf->labelsize(10);
          adhrbf->labelcolor(FL_FOREGROUND_COLOR);
          adhrbf->maximum(255);
          adhrbf->step(1);
          adhrbf->callback((Fl_Callback*)cb_adhrbf);
          adhrbf->align(Fl_Align(FL_ALIGN_BOTTOM));
          adhrbf->when(FL_WHEN_CHANGED);
          o->init("Padaptiveharmonicsbasefreq");o->reset_value=128;
        } // Fl_Osc_Dial* adhrbf
        { Fl_Osc_TSlider* o = adhrpar = new Fl_Osc_TSlider(675, 450, 55, 10);
          adhrpar->type(5);
          adhrpar->box(FL_NO_BOX);
          adhrpar->color(FL_BACKGROUND_COLOR);
          adhrpar->selection_color(FL_BACKGROUND_COLOR);
          adhrpar->labeltype(FL_NORMAL_LABEL);
          adhrpar->labelfont(0);
          adhrpar->labelsize(14);
          adhrpar->labelcolor(FL_FOREGROUND_COLOR);
          adhrpar->maximum(100);
          adhrpar->step(1);
          adhrpar->value(50);
          adhrpar->callback((Fl_Callback*)cb_adhrpar);
          adhrpar->align(Fl_Align(FL_ALIGN_BOTTOM));
          adhrpar->when(FL_WHEN_CHANGED);
          o->init("Padaptiveharmonicspar", 'i');o->reset_value=50;
        } // Fl_Osc_TSlider* adhrpar
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(445, 313, 150, 30);
        o->box(FL_UP_FRAME);
        { Fl_Osc_Choice* o = modtype = new Fl_Osc_Choice(475, 320, 50, 15, "Mod.");
          modtype->tooltip("modulation");
          modtype->box(FL_UP_BOX);
          modtype->down_box(FL_BORDER_BOX);
          modtype->color(FL_BACKGROUND_COLOR);
          modtype->selection_color(FL_SELECTION_COLOR);
          modtype->labeltype(FL_NORMAL_LABEL);
          modtype->labelfont(0);
          modtype->labelsize(10);
          modtype->labelcolor(FL_FOREGROUND_COLOR);
          modtype->textsize(10);
          modtype->callback((Fl_Callback*)cb_modtype);
          modtype->align(Fl_Align(FL_ALIGN_LEFT));
          modtype->when(FL_WHEN_CHANGED);
          modtype->menu(menu_modtype);
          o->init("Pmodulation");
        } // Fl_Osc_Choice* modtype
        { Fl_Osc_Dial* o = modpar1 = new Fl_Osc_Dial(535, 320, 15, 15);
          modpar1->tooltip("Oscillator\'s modulation parameter 1");
          modpar1->box(FL_NO_BOX);
          modpar1->color(FL_BACKGROUND_COLOR);
          modpar1->selection_color(FL_INACTIVE_COLOR);
          modpar1->labeltype(FL_NORMAL_LABEL);
          modpar1->labelfont(0);
          modpar1->labelsize(14);
          modpar1->labelcolor(FL_FOREGROUND_COLOR);
          modpar1->maximum(127);
          modpar1->step(1);
          modpar1->callback((Fl_Callback*)cb_modpar1);
          modpar1->align(Fl_Align(FL_ALIGN_BOTTOM));
          modpar1->when(FL_WHEN_CHANGED);
          o->init("Pmodulationpar1");o->reset_value=64;
        } // Fl_Osc_Dial* modpar1
        { Fl_Osc_Dial* o = modpar2 = new Fl_Osc_Dial(555, 320, 15, 15);
          modpar2->tooltip("Oscillator\'s modulation parameter 2");
          modpar2->box(FL_NO_BOX);
          modpar2->color(FL_BACKGROUND_COLOR);
          modpar2->selection_color(FL_INACTIVE_COLOR);
          modpar2->labeltype(FL_NORMAL_LABEL);
          modpar2->labelfont(0);
          modpar2->labelsize(14);
          modpar2->labelcolor(FL_FOREGROUND_COLOR);
          modpar2->maximum(127);
          modpar2->step(1);
          modpar2->callback((Fl_Callback*)cb_modpar2);
          modpar2->align(Fl_Align(FL_ALIGN_BOTTOM));
          modpar2->when(FL_WHEN_CHANGED);
          o->init("Pmodulationpar2");o->reset_value=64;
        } // Fl_Osc_Dial* modpar2
        { Fl_Osc_Dial* o = modpar3 = new Fl_Osc_Dial(575, 320, 15, 15);
          modpar3->tooltip("Oscillator\'s modulation parameter 3");
          modpar3->box(FL_NO_BOX);
          modpar3->color(FL_BACKGROUND_COLOR);
          modpar3->selection_color(FL_INACTIVE_COLOR);
          modpar3->labeltype(FL_NORMAL_LABEL);
          modpar3->labelfont(0);
          modpar3->labelsize(14);
          modpar3->labelcolor(FL_FOREGROUND_COLOR);
          modpar3->maximum(127);
          modpar3->step(1);
          modpar3->callback((Fl_Callback*)cb_modpar3);
          modpar3->align(Fl_Align(FL_ALIGN_BOTTOM));
          modpar3->when(FL_WHEN_CHANGED);
          o->init("Pmodulationpar3");o->reset_value=32;
        } // Fl_Osc_Dial* modpar3
        o->end();
      } // Fl_Group* o
      { Fl_Button* o = new Fl_Button(675, 530, 55, 15, "Sine");
        o->box(FL_THIN_UP_BOX);
        o->labelfont(1);
        o->labelsize(11);
        o->callback((Fl_Callback*)cb_Sine);
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(675, 550, 25, 15, "C");
        o->box(FL_THIN_UP_BOX);
        o->color((Fl_Color)179);
        o->labelfont(1);
        o->labelsize(11);
        o->labelcolor((Fl_Color)55);
        o->callback((Fl_Callback*)cb_C);
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(705, 550, 25, 15, "P");
        o->box(FL_THIN_UP_BOX);
        o->color((Fl_Color)179);
        o->labelfont(1);
        o->labelsize(11);
        o->labelcolor((Fl_Color)55);
        o->callback((Fl_Callback*)cb_P);
      } // Fl_Button* o
      { _this_has_to_be_the_last = new Fl_Scroll(10, 345, 660, 250);
        _this_has_to_be_the_last->type(1);
        _this_has_to_be_the_last->box(FL_FLAT_BOX);
        { Fl_Pack* o = harmonics = new Fl_Pack(15, 350, 650, 225);
          harmonics->type(1);
          for (int i=0;i<(MAX_AD_HARMONICS - 1);i++){h[i]=new Oscilharmonic(0,0,20,o->h(),"");h[i]->init(i,oscildisplaygroup,loc,osc);}
          harmonics->end();
        } // Fl_Pack* harmonics
        _this_has_to_be_the_last->end();
      } // Fl_Scroll* _this_has_to_be_the_last
      dummy->end();
    } // Fl_Osc_Group* dummy
    (void)o;//if (oscil->ADvsPAD) o->label("PADsynth Harmonic Content Editor");
    osceditUI->end();
  } // Fl_Double_Window* osceditUI
  return osceditUI;
}

OscilEditor::OscilEditor(bool adnotep_, std::string loc_, Fl_Osc_Interface *osc_) {
  assert(osc_);
  assert(!loc_.empty());
  
  initialized = false;
  
  adnotep = adnotep_;
  osc = osc_;
  loc = loc_;
  
  oscilo = NULL;
  oscilo_base = NULL;
  oscils = NULL;
  oscils_base = NULL;
  
  osceditUI = NULL;
  dummy = NULL;
  applybutton = NULL;
  oscildisplaygroup = NULL;
  rndslider = NULL;
  hrndtype = NULL;
  magtype = NULL;
  basefuncdisplaygroup = NULL;
  bfpar = NULL;
  bftype = NULL;
  make_window();
  bftype->init("Pcurrentbasefunc");
  initialized = true;
  
  refresh();
  osceditUI->show();
}

OscilEditor::~OscilEditor() {
  osceditUI->hide();
  for (int i=0; i<(MAX_AD_HARMONICS - 1); ++i)
      delete h[i];
  
  delete oscilo;
  delete oscilo_base;
  delete oscils;
  delete oscils_base;
  delete osceditUI;
}

void OscilEditor::refresh() {
  magtype->update();
  
      for (int i=0;i<(MAX_AD_HARMONICS - 1);i++) h[i]->refresh();
  
      osc->requestValue(loc+"prepare");
  
      basefuncdisplaygroup->redraw();
  redrawoscil();
}

void OscilEditor::redrawoscil() {
  if(!initialized) //Must have been called during initialization
          return;
      //get data from backend
  osc->requestValue(loc+"prepare");
  oscilo->update();
  oscils->update();
  oscilo_base->update();
  oscils_base->update();
}

void OscilEditor::setbfmodstatus(int menuentry) {
  switch (menuentry){
      case 0:
           bfpar->deactivate();
           bfparval->deactivate();
           basefuncmodulation->deactivate();
           break;
      case 127:
           bfpar->deactivate();
           bfparval->deactivate();
           basefuncmodulation->activate();
           break;
      default:
           bfpar->activate();
           bfparval->activate();
           basefuncmodulation->activate();
      }
}
